From 02bf956b81a86635d01db551af3e1adee1db8ef9 Mon Sep 17 00:00:00 2001
From: Francois Berenger <unixjunkie@sdf.org>
Date: Wed, 31 Jul 2019 15:32:04 +0900
Subject: [PATCH 31/42] BatInt32: 4.08 compat

---
 src/batInt32.mliv | 24 ++++++++++++++++++++++++
 src/batInt32.mlv  |  6 ++++--
 2 files changed, 28 insertions(+), 2 deletions(-)

diff --git a/src/batInt32.mliv b/src/batInt32.mliv
index a00dbf4b..e258a950 100644
--- a/src/batInt32.mliv
+++ b/src/batInt32.mliv
@@ -75,12 +75,23 @@ external div : int32 -> int32 -> int32 = "%int32_div"
     its arguments towards zero, as specified for {!Pervasives.(/)}.
     @raise Division_by_zero if the second argument is zero. *)
 
+##V>=4.08##val unsigned_div : int32 -> int32 -> int32
+##V>=4.08##(** Same as {!div}, except that arguments and result are interpreted as {e
+##V>=4.08##    unsigned} 32-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 external rem : int32 -> int32 -> int32 = "%int32_mod"
 (** Integer remainder.  If [y] is not zero, the result
     of [Int32.rem x y] satisfies the following property:
     [x = Int32.add (Int32.mul (Int32.div x y) y) (Int32.rem x y)].
     @raise Division_by_zero if the second argument is zero. *)
 
+##V>=4.08##val unsigned_rem : int32 -> int32 -> int32
+##V>=4.08##(** Same as {!rem}, except that arguments and result are interpreted as {e
+##V>=4.08##    unsigned} 32-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
 
 val modulo : int32 -> int32 -> int32
 val pow  : int32 -> int32 -> int32
@@ -154,6 +165,13 @@ external to_int : int32 -> int = "%int32_to_int"
     during the conversion.  On 64-bit platforms, the conversion
     is exact. *)
 
+##V>=4.08##val unsigned_to_int : int32 -> int option
+##V>=4.08##(** Same as {!to_int}, but interprets the argument as an {e unsigned} integer.
+##V>=4.08##    Returns [None] if the unsigned value of the argument cannot fit into an
+##V>=4.08##    [int].
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 external of_float : float -> int32 = "caml_int32_of_float"
 ##V>=4.3## "caml_int32_of_float_unboxed" [@@unboxed] [@@noalloc]
 (** Convert the given floating-point number to a 32-bit integer,
@@ -239,6 +257,12 @@ val compare : t -> t -> int
     allows the module [Int32] to be passed as argument to the functors
     {!Set.Make} and {!Map.Make}. *)
 
+##V>=4.08##val unsigned_compare: t -> t -> int
+##V>=4.08##(** Same as {!compare}, except that arguments are interpreted as {e unsigned}
+##V>=4.08##    32-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 val equal : t -> t -> bool
 (** Equality function for 32-bit integers, useful for {!HashedType}. *)
 
diff --git a/src/batInt32.mlv b/src/batInt32.mlv
index 836e0a2e..a0240b8d 100644
--- a/src/batInt32.mlv
+++ b/src/batInt32.mlv
@@ -168,8 +168,10 @@ external float_of_bits : int32 -> float = "caml_int32_float_of_bits"
 ##V>=4.3## "caml_int32_float_of_bits_unboxed" [@@unboxed] [@@noalloc]
 external format : string -> int32 -> string = "caml_int32_format"
 
-
-
+##V>=4.08##let unsigned_div = Int32.unsigned_div
+##V>=4.08##let unsigned_rem = Int32.unsigned_rem
+##V>=4.08##let unsigned_to_int = Int32.unsigned_to_int
+##V>=4.08##let unsigned_compare = Int32.unsigned_compare
 
 type bounded = t
 let min_num, max_num = min_int, max_int
-- 
2.22.0

