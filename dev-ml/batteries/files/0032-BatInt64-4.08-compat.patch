From 6e7ee352344647b8e7210b41ba9286ce1453064d Mon Sep 17 00:00:00 2001
From: Francois Berenger <unixjunkie@sdf.org>
Date: Wed, 31 Jul 2019 15:32:57 +0900
Subject: [PATCH 32/42] BatInt64: 4.08 compat

---
 src/batInt64.mliv | 25 +++++++++++++++++++++++++
 src/batInt64.mlv  |  4 ++++
 2 files changed, 29 insertions(+)

diff --git a/src/batInt64.mliv b/src/batInt64.mliv
index 01e72ffc..74880394 100644
--- a/src/batInt64.mliv
+++ b/src/batInt64.mliv
@@ -77,12 +77,24 @@ external div : int64 -> int64 -> int64 = "%int64_div"
     its arguments towards zero, as specified for {!Pervasives.(/)}.
     @raise Division_by_zero if the second argument is zero. *)
 
+##V>=4.08##val unsigned_div : int64 -> int64 -> int64
+##V>=4.08##(** Same as {!div}, except that arguments and result are interpreted as {e
+##V>=4.08##    unsigned} 64-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 external rem : int64 -> int64 -> int64 = "%int64_mod"
 (** Integer remainder.  If [y] is not zero, the result
     of [Int64.rem x y] satisfies the following property:
     [x = Int64.add (Int64.mul (Int64.div x y) y) (Int64.rem x y)].
     @raise Division_by_zero if the second argument is zero. *)
 
+##V>=4.08##val unsigned_rem : int64 -> int64 -> int64
+##V>=4.08##(** Same as {!rem}, except that arguments and result are interpreted as {e
+##V>=4.08##    unsigned} 64-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 val succ : int64 -> int64
 (** Successor.  [Int64.succ x] is [Int64.add x Int64.one]. *)
 
@@ -150,6 +162,13 @@ external to_int : int64 -> int = "%int64_to_int"
     is taken modulo 2{^31}, i.e. the top 33 bits are lost
     during the conversion. *)
 
+##V>=4.08##val unsigned_to_int : int64 -> int option
+##V>=4.08##(** Same as {!to_int}, but interprets the argument as an {e unsigned} integer.
+##V>=4.08##    Returns [None] if the unsigned value of the argument cannot fit into an
+##V>=4.08##    [int].
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 external of_float : float -> int64 = "caml_int64_of_float"
 ##V>=4.3## "caml_int64_of_float_unboxed" [@@unboxed] [@@noalloc]
 (** Convert the given floating-point number to a 64-bit integer,
@@ -220,6 +239,12 @@ val compare : t -> t -> int
     allows the module [Int64] to be passed as argument to the functors
     {!Set.Make} and {!Map.Make}. *)
 
+##V>=4.08##val unsigned_compare: t -> t -> int
+##V>=4.08##(** Same as {!compare}, except that arguments are interpreted as {e unsigned}
+##V>=4.08##    64-bit integers.
+##V>=4.08##
+##V>=4.08##    @since 4.08.0 *)
+
 val equal : t -> t -> bool
 (** Equality function for 64-bit integers, useful for {!HashedType}. *)
 
diff --git a/src/batInt64.mlv b/src/batInt64.mlv
index c650d686..b6d8c557 100644
--- a/src/batInt64.mlv
+++ b/src/batInt64.mlv
@@ -64,6 +64,10 @@ external float_of_bits : int64 -> float = "caml_int64_float_of_bits"
 ##V>=4.3## "caml_int64_float_of_bits_unboxed" [@@unboxed] [@@noalloc]
 external format : string -> int64 -> string = "caml_int64_format"
 
+##V>=4.08##let unsigned_compare = Int64.unsigned_compare
+##V>=4.08##let unsigned_to_int = Int64.unsigned_to_int
+##V>=4.08##let unsigned_rem = Int64.unsigned_rem
+##V>=4.08##let unsigned_div = Int64.unsigned_div
 
 let print out t = BatInnerIO.nwrite out (to_string t)
 let print_hex out t = BatPrintf.fprintf out "%Lx" t
-- 
2.22.0

