Index: ocaml-containers-2.5/qtest/dune
===================================================================
--- ocaml-containers-2.5.orig/qtest/dune
+++ ocaml-containers-2.5/qtest/dune
@@ -18,7 +18,7 @@
   (modules run_qtest)
   ; disable some warnings in qtests
   (flags :standard -warn-error -a -w -33-35-27-39 -nolabels)
-  (libraries sequence gen qcheck containers containers.unix
+  (libraries iter gen qcheck containers containers.unix
              containers.data containers.thread containers.iter
              containers.sexp uutf)
   )
Index: ocaml-containers-2.5/src/core/CCHeap.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCHeap.ml
+++ ocaml-containers-2.5/src/core/CCHeap.ml
@@ -58,7 +58,7 @@ end
 (*$QR & ~count:30
   Q.(list_of_size Gen.(return 1_000) int) (fun l ->
     (* put elements into a heap *)
-    let h = H.of_seq (Sequence.of_list l) in
+    let h = H.of_seq (Iter.of_list l) in
     OUnit.assert_equal 1_000 (H.size h);
     let l' = extract_list h in
     is_sorted l'
@@ -69,10 +69,10 @@ end
 (*$QR & ~count:30
   Q.(list_of_size Gen.(return 1_000) int) (fun l ->
     (* put elements into a heap *)
-    let h = H.of_seq (Sequence.of_list l) in
+    let h = H.of_seq (Iter.of_list l) in
     let h = H.filter (fun x->x mod 2=0) h in
     OUnit.assert_bool "all odd"
-      (H.to_seq h |> Sequence.for_all (fun x -> x mod 2 = 0));
+      (H.to_seq h |> Iter.for_all (fun x -> x mod 2 = 0));
     let l' = extract_list h in
     is_sorted l'
   )
@@ -81,8 +81,8 @@ end
 (*$QR
   Q.(list_of_size Gen.(return 1_000) int) (fun l ->
     (* put elements into a heap *)
-    let h = H.of_seq (Sequence.of_list l) in
-    let l' = H.to_seq_sorted h |> Sequence.to_list in
+    let h = H.of_seq (Iter.of_list l) in
+    let l' = H.to_seq_sorted h |> Iter.to_list in
     is_sorted l'
   )
 *)
Index: ocaml-containers-2.5/src/core/CCInt.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCInt.ml
+++ ocaml-containers-2.5/src/core/CCInt.ml
@@ -27,9 +27,9 @@ let range i j yield =
   if i<=j then up i j yield else down i j yield
 
 (*$= & ~printer:Q.Print.(list int)
-  [0;1;2;3;4;5] (range 0 5 |> Sequence.to_list)
-  [0]           (range 0 0 |> Sequence.to_list)
-  [5;4;3;2]     (range 5 2 |> Sequence.to_list)
+  [0;1;2;3;4;5] (range 0 5 |> Iter.to_list)
+  [0]           (range 0 0 |> Iter.to_list)
+  [5;4;3;2]     (range 5 2 |> Iter.to_list)
 *)
 
 let range' i j yield =
@@ -38,9 +38,9 @@ let range' i j yield =
   else range i (j+1) yield
 
 (*$= & ~printer:Q.Print.(list int)
-  []          (range' 0 0 |> Sequence.to_list)
-  [0;1;2;3;4] (range' 0 5 |> Sequence.to_list)
-  [5;4;3]     (range' 5 2 |> Sequence.to_list)
+  []          (range' 0 0 |> Iter.to_list)
+  [0;1;2;3;4] (range' 0 5 |> Iter.to_list)
+  [5;4;3]     (range' 5 2 |> Iter.to_list)
 *)
 
 let sign i =
@@ -258,23 +258,23 @@ let range_by ~step i j yield =
 
 (* note: the last test checks that no error occurs due to overflows. *)
 (*$= & ~printer:Q.Print.(list int)
-  [0]     (range_by ~step:1   0 0     |> Sequence.to_list)
-  []      (range_by ~step:1   5 0     |> Sequence.to_list)
-  []      (range_by ~step:2   1 0     |> Sequence.to_list)
-  [0;2;4] (range_by ~step:2   0 4     |> Sequence.to_list)
-  [0;2;4] (range_by ~step:2   0 5     |> Sequence.to_list)
-  [0]     (range_by ~step:~-1 0 0     |> Sequence.to_list)
-  []      (range_by ~step:~-1 0 5     |> Sequence.to_list)
-  []      (range_by ~step:~-2 0 1     |> Sequence.to_list)
-  [5;3;1] (range_by ~step:~-2 5 1     |> Sequence.to_list)
-  [5;3;1] (range_by ~step:~-2 5 0     |> Sequence.to_list)
-  [0]     (range_by ~step:max_int 0 2 |> Sequence.to_list)
+  [0]     (range_by ~step:1   0 0     |> Iter.to_list)
+  []      (range_by ~step:1   5 0     |> Iter.to_list)
+  []      (range_by ~step:2   1 0     |> Iter.to_list)
+  [0;2;4] (range_by ~step:2   0 4     |> Iter.to_list)
+  [0;2;4] (range_by ~step:2   0 5     |> Iter.to_list)
+  [0]     (range_by ~step:~-1 0 0     |> Iter.to_list)
+  []      (range_by ~step:~-1 0 5     |> Iter.to_list)
+  []      (range_by ~step:~-2 0 1     |> Iter.to_list)
+  [5;3;1] (range_by ~step:~-2 5 1     |> Iter.to_list)
+  [5;3;1] (range_by ~step:~-2 5 0     |> Iter.to_list)
+  [0]     (range_by ~step:max_int 0 2 |> Iter.to_list)
 *)
 
 (*$Q
   Q.(pair small_int small_int) (fun (i,j) -> \
     let i = min i j and j = max i j in \
     CCList.equal CCInt.equal \
-      (CCInt.range_by ~step:1 i j |> Sequence.to_list) \
-      (CCInt.range i j |> Sequence.to_list) )
+      (CCInt.range_by ~step:1 i j |> Iter.to_list) \
+      (CCInt.range i j |> Iter.to_list) )
 *)
Index: ocaml-containers-2.5/src/core/CCOpt.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCOpt.ml
+++ ocaml-containers-2.5/src/core/CCOpt.ml
@@ -189,9 +189,9 @@ let choice_seq s =
   !r
 
 (*$T
-  choice_seq (Sequence.of_list [None; Some 1; Some 2]) = Some 1
-  choice_seq Sequence.empty = None
-  choice_seq (Sequence.repeat None |> Sequence.take 100) = None
+  choice_seq (Iter.of_list [None; Some 1; Some 2]) = Some 1
+  choice_seq Iter.empty = None
+  choice_seq (Iter.repeat None |> Iter.take 100) = None
 *)
 
 let to_gen o =
Index: ocaml-containers-2.5/src/core/CCString.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCString.ml
+++ ocaml-containers-2.5/src/core/CCString.ml
@@ -1135,14 +1135,14 @@ module Sub = struct
 
   (*$QR
     Q.(printable_string_of_size Gen.(3--10)) (fun s ->
-      let open Sequence.Infix in
+      let open Iter.Infix in
       begin
         (0 -- (length s-2)
           >|= fun i -> i, Sub.make s i ~len:(length s-i))
         >>= fun (i,sub) ->
         (0 -- (Sub.length sub-1) >|= fun j -> i,j,sub)
       end
-      |> Sequence.for_all
+      |> Iter.for_all
         (fun (i,j,sub) -> Sub.get sub j = s.[i+j]))
   *)
 
Index: ocaml-containers-2.5/src/core/CCUtf8_string.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCUtf8_string.ml
+++ ocaml-containers-2.5/src/core/CCUtf8_string.ml
@@ -325,8 +325,8 @@ let of_string s = if is_valid s then Som
   Q.small_string (fun s ->
     Q.assume (is_valid s && uutf_is_valid s);
     let pp s = Q.Print.(list pp_uchar) s in
-    let l_uutf = uutf_to_seq s |> Sequence.to_list in
-    let l_co = of_string_exn s |> to_seq |> Sequence.to_list in
+    let l_uutf = uutf_to_seq s |> Iter.to_list in
+    let l_co = of_string_exn s |> to_seq |> Iter.to_list in
     if l_uutf = l_co then true
     else Q.Test.fail_reportf "uutf: '%s', containers: '%s', is_valid %B, uutf_is_valid %B"
       (pp l_uutf) (pp l_co) (is_valid s) (uutf_is_valid s)
Index: ocaml-containers-2.5/src/core/CCVector.ml
===================================================================
--- ocaml-containers-2.5.orig/src/core/CCVector.ml
+++ ocaml-containers-2.5/src/core/CCVector.ml
@@ -125,11 +125,11 @@ let clear v =
   v.size <- 0
 
 (*$R
-  let v = of_seq Sequence.(1 -- 10) in
+  let v = of_seq Iter.(1 -- 10) in
   OUnit.assert_equal 10 (size v);
   clear v;
   OUnit.assert_equal 0 (size v);
-  OUnit.assert_bool "empty_after_clear" (Sequence.is_empty (to_seq v));
+  OUnit.assert_bool "empty_after_clear" (Iter.is_empty (to_seq v));
 *)
 
 let is_empty v = v.size = 0
@@ -176,12 +176,12 @@ let append a b =
 *)
 
 (*$R
-  let a = of_seq Sequence.(1 -- 5) in
-  let b = of_seq Sequence.(6 -- 10) in
+  let a = of_seq Iter.(1 -- 5) in
+  let b = of_seq Iter.(6 -- 10) in
   append a b;
   OUnit.assert_equal 10 (size a);
-  OUnit.assert_equal (Sequence.to_array Sequence.(1 -- 10)) (to_array a);
-  OUnit.assert_equal (Sequence.to_array Sequence.(6 -- 10)) (to_array b);
+  OUnit.assert_equal (Iter.to_array Iter.(1 -- 10)) (to_array a);
+  OUnit.assert_equal (Iter.to_array Iter.(6 -- 10)) (to_array b);
 *)
 
 let get v i =
@@ -269,8 +269,8 @@ let rec append_gen a b = match b() with
   (Q.pair (gen Q.int) (gen Q.int)) (fun (v1,v2) ->
     let l1 = to_list v1 in
     append v1 v2;
-    Sequence.to_list (to_seq v1) =
-      Sequence.(to_list (append (of_list l1) (to_seq v2)))
+    Iter.to_list (to_seq v1) =
+      Iter.(to_list (append (of_list l1) (to_seq v2)))
   )
 *)
 
@@ -359,7 +359,7 @@ let copy v = {
 *)
 
 (*$R
-  let v = of_seq Sequence.(1 -- 100) in
+  let v = of_seq Iter.(1 -- 100) in
   OUnit.assert_equal 100 (size v);
   let v' = copy v in
   OUnit.assert_equal 100 (size v');
@@ -386,7 +386,7 @@ let shrink v n =
   )
 
 (*$R
-  let v = of_seq Sequence.(1 -- 10) in
+  let v = of_seq Iter.(1 -- 10) in
   shrink v 5;
   OUnit.assert_equal [1;2;3;4;5] (to_list v);
 *)
@@ -395,7 +395,7 @@ let shrink v n =
   (gen Q.small_int) (fun v ->
     let n = size v / 2 in
     let l = to_list v in
-    let h = Sequence.(to_list (take n (of_list l))) in
+    let h = Iter.(to_list (take n (of_list l))) in
     let v' = copy v in
     shrink v' n;
     h = to_list v'
@@ -782,13 +782,13 @@ let rev_iter f v =
   done
 
 (*$T
-  let v = of_list [1;2;3] in (fun f->rev_iter f v) |> Sequence.to_list = [3;2;1]
+  let v = of_list [1;2;3] in (fun f->rev_iter f v) |> Iter.to_list = [3;2;1]
 *)
 
 (*$Q
   Q.(list int) (fun l -> \
     let v = of_list l in \
-    (fun f->rev_iter f v) |> Sequence.to_list = List.rev l)
+    (fun f->rev_iter f v) |> Iter.to_list = List.rev l)
 *)
 
 let size v = v.size
@@ -804,7 +804,7 @@ let of_seq ?(init=create ()) seq =
   init
 
 (*$T
-  of_seq Sequence.(1 -- 10) |> to_list = CCList.(1 -- 10)
+  of_seq Iter.(1 -- 10) |> to_list = CCList.(1 -- 10)
 *)
 
 let to_seq v k = iter k v
@@ -817,7 +817,7 @@ let to_seq_rev v k =
 
 (*$Q
   Q.(list int) (fun l -> \
-    let v= of_list l in v |> to_seq_rev |> Sequence.to_rev_list = l)
+    let v= of_list l in v |> to_seq_rev |> Iter.to_rev_list = l)
 *)
 
 let slice_seq v start len =
Index: ocaml-containers-2.5/src/data/CCBV.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCBV.ml
+++ ocaml-containers-2.5/src/data/CCBV.ml
@@ -262,16 +262,16 @@ let iter bv f =
 *)
 
 (*$= & ~printer:Q.Print.(list (pair int bool))
-  [] (iter (create ~size:0 false) |> seq_zip |> Sequence.to_list)
+  [] (iter (create ~size:0 false) |> seq_zip |> Iter.to_list)
   [0, false; 1, true; 2, false] \
-    (iter (let bv = create ~size:3 false in set bv 1; bv) |> seq_zip |> Sequence.to_list)
+    (iter (let bv = create ~size:3 false in set bv 1; bv) |> seq_zip |> Iter.to_list)
 *)
 
 (*$Q
   Q.(small_int) (fun n -> \
     assert (n >= 0); \
     let bv = create ~size:n true in \
-    let l = iter bv |> seq_zip |> Sequence.to_list in \
+    let l = iter bv |> seq_zip |> Iter.to_list in \
     List.length l = n && List.for_all (fun (_,b) -> b) l)
 *)
 
@@ -279,7 +279,7 @@ let iter_true bv f =
   iter bv (fun i b -> if b then f i else ())
 
 (*$T
-  of_list [1;5;7] |> iter_true |> Sequence.to_list |> List.sort CCOrd.compare = [1;5;7]
+  of_list [1;5;7] |> iter_true |> Iter.to_list |> List.sort CCOrd.compare = [1;5;7]
 *)
 
 (*$inject
@@ -292,7 +292,7 @@ let iter_true bv f =
 
 (*$QR
   gen_bv (fun bv ->
-    let l' = Sequence.to_rev_list (CCBV.iter_true bv) in
+    let l' = Iter.to_rev_list (CCBV.iter_true bv) in
     let bv' = CCBV.of_list l' in
     CCBV.cardinal bv = CCBV.cardinal bv'
   )
@@ -538,7 +538,7 @@ let to_seq bv k = iter_true bv k
   Q.(small_int) (fun i -> \
       let i = max 1 i in \
       let bv = create ~size:i true in \
-      i = (to_seq bv |> Sequence.length))
+      i = (to_seq bv |> Iter.length))
 *)
 
 let of_seq seq =
Index: ocaml-containers-2.5/src/data/CCDeque.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCDeque.ml
+++ ocaml-containers-2.5/src/data/CCDeque.ml
@@ -33,9 +33,9 @@ type 'a t = {
 
 (*$R
   let q = create () in
-  add_seq_back q Sequence.(3 -- 5);
+  add_seq_back q Iter.(3 -- 5);
   assert_equal [3;4;5] (to_list q);
-  add_seq_front q Sequence.(of_list [2;1]);
+  add_seq_front q Iter.(of_list [2;1]);
   assert_equal [1;2;3;4;5] (to_list q);
   push_front q 0;
   assert_equal [0;1;2;3;4;5] (to_list q);
@@ -57,7 +57,7 @@ let clear q =
   ()
 
 (*$R
-  let q = of_seq Sequence.(1 -- 100) in
+  let q = of_seq Iter.(1 -- 100) in
   assert_equal 100 (length q);
   clear q;
   assert_equal 0 (length q);
@@ -117,7 +117,7 @@ let peek_front d = match d.cur.cell with
 *)
 
 (*$R
-  let d = of_seq Sequence.(1 -- 10) in
+  let d = of_seq Iter.(1 -- 10) in
   let printer = pint in
   OUnit.assert_equal ~printer 1 (peek_front d);
   push_front d 42;
@@ -143,7 +143,7 @@ let peek_back d =
 *)
 
 (*$R
-  let d = of_seq Sequence.(1 -- 10) in
+  let d = of_seq Iter.(1 -- 10) in
   let printer = pint in
   OUnit.assert_equal ~printer 1 (peek_front d);
   push_back d 42;
@@ -229,9 +229,9 @@ let iter f d =
 *)
 
 (*$R
-  let d = of_seq Sequence.(1 -- 5) in
-  let s = Sequence.from_iter (fun k -> iter k d) in
-  let l = Sequence.to_list s in
+  let d = of_seq Iter.(1 -- 5) in
+  let s = Iter.from_iter (fun k -> iter k d) in
+  let l = Iter.to_list s in
   OUnit.assert_equal ~printer:plist [1;2;3;4;5] l;
 *)
 
@@ -275,7 +275,7 @@ let length d = d.size
 *)
 
 (*$R
-  let d = of_seq Sequence.(1 -- 10) in
+  let d = of_seq Iter.(1 -- 10) in
   OUnit.assert_equal ~printer:pint 10 (length d)
 *)
 
@@ -288,9 +288,9 @@ let add_seq_front q seq = seq (fun x ->
 
 (*$R
   let q = of_list [4;5] in
-  add_seq_front q Sequence.(of_list [3;2;1]);
+  add_seq_front q Iter.(of_list [3;2;1]);
   assert_equal [1;2;3;4;5] (to_list q);
-  add_seq_back q Sequence.(of_list [6;7]);
+  add_seq_back q Iter.(of_list [6;7]);
   assert_equal [1;2;3;4;5;6;7] (to_list q);
 *)
 
@@ -303,7 +303,7 @@ let to_seq d k = iter k d
 
 (*$Q
   Q.(list int) (fun l -> \
-    Sequence.of_list l |> of_seq |> to_seq |> Sequence.to_list = l)
+    Iter.of_list l |> of_seq |> to_seq |> Iter.to_list = l)
 *)
 
 let of_list l =
Index: ocaml-containers-2.5/src/data/CCFQueue.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCFQueue.ml
+++ ocaml-containers-2.5/src/data/CCFQueue.ml
@@ -95,7 +95,7 @@ let rec snoc : type a. a t -> a -> a t
   let q = List.fold_left snoc empty [1;2;3;4;5] in
   let q = tail q in
   let q = List.fold_left snoc q [6;7;8] in
-  let l = Sequence.to_list (to_seq q) in
+  let l = Iter.to_list (to_seq q) in
   OUnit.assert_equal ~printer:pp_ilist [2;3;4;5;6;7;8] l
 *)
 
@@ -321,7 +321,7 @@ let add_seq_front seq q =
 
 (*$Q
   Q.(pair (list int) (list int)) (fun (l1, l2) -> \
-    add_seq_front (Sequence.of_list l1) (of_list l2) |> to_list = l1 @ l2)
+    add_seq_front (Iter.of_list l1) (of_list l2) |> to_list = l1 @ l2)
 *)
 
 let add_seq_back q seq =
@@ -345,7 +345,7 @@ let rec to_seq : 'a. 'a t -> 'a sequence
 
 (*$Q
   (Q.list Q.int) (fun l -> \
-    of_list l |> to_seq |> Sequence.to_list = l)
+    of_list l |> to_seq |> Iter.to_list = l)
 *)
 
 let append q1 q2 =
@@ -360,10 +360,10 @@ let append q1 q2 =
 *)
 
 (*$R
-  let q1 = of_seq (Sequence.of_list [1;2;3;4]) in
-  let q2 = of_seq (Sequence.of_list [5;6;7;8]) in
+  let q1 = of_seq (Iter.of_list [1;2;3;4]) in
+  let q2 = of_seq (Iter.of_list [5;6;7;8]) in
   let q = append q1 q2 in
-  let l = Sequence.to_list (to_seq q) in
+  let l = Iter.to_list (to_seq q) in
   OUnit.assert_equal ~printer:pp_ilist [1;2;3;4;5;6;7;8] l
 *)
 
@@ -407,7 +407,7 @@ let rec fold : 'a 'b. ('b -> 'a -> 'b) -
 *)
 
 (*$R
-  let q = of_seq (Sequence.of_list [1;2;3;4]) in
+  let q = of_seq (Iter.of_list [1;2;3;4]) in
   let n = fold (+) 0 q in
   OUnit.assert_equal 10 n;
 *)
@@ -425,7 +425,7 @@ let of_seq seq = add_seq_front seq empty
 
 (*$Q
   (Q.list Q.int) (fun l -> \
-    Sequence.of_list l |> of_seq |> to_list = l)
+    Iter.of_list l |> of_seq |> to_list = l)
 *)
 
 let rev q =
Index: ocaml-containers-2.5/src/data/CCFun_vec.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCFun_vec.ml
+++ ocaml-containers-2.5/src/data/CCFun_vec.ml
@@ -325,7 +325,7 @@ let to_seq m yield = iteri ~f:(fun _ v -
 (*$Q
   _listuniq (fun l -> \
     (List.sort Pervasives.compare l) = \
-      (l |> Sequence.of_list |> of_seq |> to_seq |> Sequence.to_list \
+      (l |> Iter.of_list |> of_seq |> to_seq |> Iter.to_list \
         |> List.sort Pervasives.compare) )
 *)
 
Index: ocaml-containers-2.5/src/data/CCGraph.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCGraph.ml
+++ ocaml-containers-2.5/src/data/CCGraph.ml
@@ -290,8 +290,8 @@ module Traverse = struct
   (*$R
     let l =
       let tbl = mk_table ~eq:CCInt.equal 128 in
-      Traverse.Event.dfs ~tbl ~eq:CCInt.equal ~graph:divisors_graph (Sequence.return 345614)
-      |> Sequence.to_list in
+      Traverse.Event.dfs ~tbl ~eq:CCInt.equal ~graph:divisors_graph (Iter.return 345614)
+      |> Iter.to_list in
     let expected =
     [`Enter (345614, 0, []); `Edge (345614, (), 172807, `Forward);
      `Enter (172807, 1, [(345614, (), 172807)]); `Edge (172807, (), 1, `Forward);
Index: ocaml-containers-2.5/src/data/CCHashTrie.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCHashTrie.ml
+++ ocaml-containers-2.5/src/data/CCHashTrie.ml
@@ -673,7 +673,7 @@ module Make(Key : KEY)
   (*$Q
     _listuniq (fun l -> \
       (List.sort Pervasives.compare l) = \
-        (l |> Sequence.of_list |> M.of_seq |> M.to_seq |> Sequence.to_list \
+        (l |> Iter.of_list |> M.of_seq |> M.to_seq |> Iter.to_list \
           |> List.sort Pervasives.compare) )
   *)
 
@@ -759,12 +759,12 @@ end
   let m = M.of_list CCList.( (501 -- 1000) @ (500 -- 1) |> map (fun i->i,i)) in
   assert_equal ~printer:CCInt.to_string 1000 (M.cardinal m);
   assert_bool "check all get"
-    (Sequence.for_all (fun i -> i = M.get_exn i m) Sequence.(1 -- 1000));
-  let m = Sequence.(501 -- 1000 |> fold (fun m i -> M.remove i m) m) in
+    (Iter.for_all (fun i -> i = M.get_exn i m) Iter.(1 -- 1000));
+  let m = Iter.(501 -- 1000 |> fold (fun m i -> M.remove i m) m) in
   assert_equal ~printer:CCInt.to_string 500 (M.cardinal m);
   assert_bool "check all get after remove"
-    (Sequence.for_all (fun i -> i = M.get_exn i m) Sequence.(1 -- 500));
+    (Iter.for_all (fun i -> i = M.get_exn i m) Iter.(1 -- 500));
   assert_bool "check all get after remove"
-    (Sequence.for_all (fun i -> None = M.get i m) Sequence.(501 -- 1000));
+    (Iter.for_all (fun i -> None = M.get i m) Iter.(501 -- 1000));
 *)
 
Index: ocaml-containers-2.5/src/data/CCImmutArray.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCImmutArray.ml
+++ ocaml-containers-2.5/src/data/CCImmutArray.ml
@@ -87,8 +87,8 @@ let of_seq s =
 
 (*$Q
   Q.(list int) (fun l -> \
-    let g = Sequence.of_list l in \
-    of_seq g |> to_seq |> Sequence.to_list = l)
+    let g = Iter.of_list l in \
+    of_seq g |> to_seq |> Iter.to_list = l)
 *)
 
 let rec gen_to_list_ acc g = match g() with
Index: ocaml-containers-2.5/src/data/CCMixtbl.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCMixtbl.ml
+++ ocaml-containers-2.5/src/data/CCMixtbl.ml
@@ -135,7 +135,7 @@ let keys_seq tbl yield =
   set ~inj:inj_int tbl "foo" 1;
   set ~inj:inj_int tbl "bar" 2;
   set ~inj:inj_str tbl "baaz" "hello";
-  let l = keys_seq tbl |> Sequence.to_list in
+  let l = keys_seq tbl |> Iter.to_list in
   OUnit.assert_equal ["baaz"; "bar"; "foo"] (List.sort compare l);
 *)
 
@@ -163,8 +163,8 @@ let bindings tbl yield =
   set ~inj:inj_int tbl "bar" 2;
   set ~inj:inj_str tbl "baaz" "hello";
   set ~inj:inj_str tbl "str" "rts";
-  let l_int = bindings_of ~inj:inj_int tbl |> Sequence.to_list in
+  let l_int = bindings_of ~inj:inj_int tbl |> Iter.to_list in
   OUnit.assert_equal ["bar", 2; "foo", 1] (List.sort compare l_int);
-  let l_str = bindings_of ~inj:inj_str tbl |> Sequence.to_list in
+  let l_str = bindings_of ~inj:inj_str tbl |> Iter.to_list in
   OUnit.assert_equal ["baaz", "hello"; "str", "rts"] (List.sort compare l_str);
 *)
Index: ocaml-containers-2.5/src/data/CCPersistentHashtbl.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCPersistentHashtbl.ml
+++ ocaml-containers-2.5/src/data/CCPersistentHashtbl.ml
@@ -127,7 +127,7 @@ end
       4, "d";
     ]
 
-  let my_seq = Sequence.of_list my_list
+  let my_seq = Iter.of_list my_list
 
   let _list_uniq = CCList.sort_uniq
     ~cmp:(fun a b -> Pervasives.compare (fst a) (fst b))
@@ -234,9 +234,9 @@ module Make(H : HashedType) : S with typ
 
   (*$R
     let n = 10000 in
-    let seq = Sequence.map (fun i -> i, string_of_int i) Sequence.(0--n) in
+    let seq = Iter.map (fun i -> i, string_of_int i) Iter.(0--n) in
     let h = H.of_seq seq in
-    Sequence.iter
+    Iter.iter
       (fun (k,v) ->
         OUnit.assert_equal ~printer:(fun x -> x) v (H.find h k))
       seq;
@@ -268,7 +268,7 @@ module Make(H : HashedType) : S with typ
 
   (*$R
     let h = H.of_seq
-      Sequence.(map (fun i -> i, string_of_int i)
+      Iter.(map (fun i -> i, string_of_int i)
         (0 -- 200)) in
     OUnit.assert_equal 201 (H.length h);
   *)
@@ -425,12 +425,12 @@ module Make(H : HashedType) : S with typ
   *)
 
   (*$R
-    let open Sequence.Infix in
+    let open Iter.Infix in
     let n = 10000 in
-    let seq = Sequence.map (fun i -> i, string_of_int i) (0 -- n) in
+    let seq = Iter.map (fun i -> i, string_of_int i) (0 -- n) in
     let h = H.of_seq seq in
     OUnit.assert_equal (n+1) (H.length h);
-    let h = Sequence.fold (fun h i -> H.remove h i) h (0 -- 500) in
+    let h = Iter.fold (fun h i -> H.remove h i) h (0 -- 500) in
     OUnit.assert_equal (n-500) (H.length h);
     OUnit.assert_bool "is_empty" (H.is_empty (H.create 16));
   *)
@@ -609,7 +609,7 @@ module Make(H : HashedType) : S with typ
 
   (*$R
     let h = H.of_seq my_seq in
-    let l = Sequence.to_list (H.to_seq h) in
+    let l = Iter.to_list (H.to_seq h) in
     OUnit.assert_equal my_list (List.sort compare l)
   *)
 
Index: ocaml-containers-2.5/src/data/CCRAL.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCRAL.ml
+++ ocaml-containers-2.5/src/data/CCRAL.ml
@@ -539,13 +539,13 @@ let to_seq l yield = iter ~f:yield l
 
 (*$Q & ~small:List.length
   Q.(list small_int) (fun l -> \
-    of_list l |> to_seq |> Sequence.to_list = l)
+    of_list l |> to_seq |> Iter.to_list = l)
   Q.(list small_int) (fun l -> \
-    Sequence.of_list l |> of_seq |> to_list = l)
+    Iter.of_list l |> of_seq |> to_list = l)
 *)
 
 (*$T
-  add_seq (of_list [3;4]) (Sequence.of_list [1;2]) |> to_list = [1;2;3;4]
+  add_seq (of_list [3;4]) (Iter.of_list [1;2]) |> to_list = [1;2;3;4]
 *)
 
 let rec gen_iter_ f g = match g() with
Index: ocaml-containers-2.5/src/data/CCSimple_queue.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCSimple_queue.ml
+++ ocaml-containers-2.5/src/data/CCSimple_queue.ml
@@ -119,10 +119,10 @@ let of_seq s = add_seq empty s
 (*$Q
   Q.(list small_int) (fun l -> \
     equal CCInt.equal \
-      (of_seq (Sequence.of_list l)) \
+      (of_seq (Iter.of_list l)) \
       (of_list l))
   Q.(list small_int) (fun l -> \
-    l = (of_list l |> to_seq |> Sequence.to_list))
+    l = (of_list l |> to_seq |> Iter.to_list))
 *)
 
 let rec klist_iter_ k f = match k() with
Index: ocaml-containers-2.5/src/data/CCTrie.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCTrie.ml
+++ ocaml-containers-2.5/src/data/CCTrie.ml
@@ -517,10 +517,10 @@ module Make(W : WORD)
       (fun (l1,l2) ->
         let t1 = S.of_list l1 and t2 = S.of_list l2 in
         let t = S.merge (fun a _ -> Some a) t1 t2 in
-        S.to_seq t |> Sequence.for_all
+        S.to_seq t |> Iter.for_all
           (fun (k,v) -> S.find k t1 = Some v || S.find k t2 = Some v) &&
-        S.to_seq t1 |> Sequence.for_all (fun (k,v) -> S.find k t <> None) &&
-        S.to_seq t2 |> Sequence.for_all (fun (k,v) -> S.find k t <> None))
+        S.to_seq t1 |> Iter.for_all (fun (k,v) -> S.find k t <> None) &&
+        S.to_seq t2 |> Iter.for_all (fun (k,v) -> S.find k t <> None))
   *)
 
   let rec size t = match t with
@@ -671,13 +671,13 @@ module Make(W : WORD)
 
   (*$= & ~printer:CCFormat.(to_string (list (pair (list int) string)))
     [ [1], "1"; [1;2], "12"; [1;2;3], "123"; [2;1], "21" ] \
-      (T.above [1] t1 |> Sequence.to_list)
+      (T.above [1] t1 |> Iter.to_list)
     [ [1;2], "12"; [1;2;3], "123"; [2;1], "21" ] \
-      (T.above [1;1] t1 |> Sequence.to_list)
+      (T.above [1;1] t1 |> Iter.to_list)
     [ [1;2], "12"; [1], "1"; [], "[]" ] \
-      (T.below [1;2] t1 |> Sequence.to_list)
+      (T.below [1;2] t1 |> Iter.to_list)
     [ [1], "1"; [], "[]" ] \
-      (T.below [1;1] t1 |> Sequence.to_list)
+      (T.below [1;1] t1 |> Iter.to_list)
   *)
 
   (* NOTE: Regression test. See #158 *)
@@ -691,7 +691,7 @@ module Make(W : WORD)
       end) \
     in \
     let trie = TPoly.of_list [[fun () -> 'a'], 1; [fun () -> 'b'], 2] in \
-    ignore (TPoly.below [fun () -> 'a'] trie |> Sequence.to_list); \
+    ignore (TPoly.below [fun () -> 'a'] trie |> Iter.to_list); \
     true
   *)
 
@@ -714,22 +714,22 @@ module Make(W : WORD)
     Q.(list_of_size Gen.(1 -- 20) (pair gen_str small_int)) \
       (fun l -> let t = String.of_list l in \
         List.for_all (fun (k,_) -> \
-          String.above k t |> Sequence.for_all (fun (k',v) -> k' >= k)) \
+          String.above k t |> Iter.for_all (fun (k',v) -> k' >= k)) \
           l)
     Q.(list_of_size Gen.(1 -- 20) (pair gen_str small_int)) \
       (fun l -> let t = String.of_list l in \
         List.for_all (fun (k,_) -> \
-          String.below k t |> Sequence.for_all (fun (k',v) -> k' <= k)) \
+          String.below k t |> Iter.for_all (fun (k',v) -> k' <= k)) \
           l)
     Q.(list_of_size Gen.(1 -- 20) (pair gen_str small_int)) \
       (fun l -> let t = String.of_list l in \
         List.for_all (fun (k,_) -> \
-          String.above k t |> Sequence.to_list |> sorted ~rev:false) \
+          String.above k t |> Iter.to_list |> sorted ~rev:false) \
           l)
     Q.(list_of_size Gen.(1 -- 20) (pair gen_str small_int)) \
       (fun l -> let t = String.of_list l in \
         List.for_all (fun (k,_) -> \
-          String.below k t |> Sequence.to_list |> sorted ~rev:true) \
+          String.below k t |> Iter.to_list |> sorted ~rev:true) \
           l)
   *)
 end
Index: ocaml-containers-2.5/src/data/CCWBTree.ml
===================================================================
--- ocaml-containers-2.5.orig/src/data/CCWBTree.ml
+++ ocaml-containers-2.5/src/data/CCWBTree.ml
@@ -500,8 +500,8 @@ module MakeFull(K : KEY) : S with type k
       List.for_all (fun (k,v) ->
         let l, v', r = M.split k m in
         v' = Some v
-        && (M.to_seq l |> Sequence.for_all (fun (k',_) -> k' < k))
-        && (M.to_seq r |> Sequence.for_all (fun (k',_) -> k' > k))
+        && (M.to_seq l |> Iter.for_all (fun (k',_) -> k' < k))
+        && (M.to_seq r |> Iter.for_all (fun (k',_) -> k' > k))
         && M.balanced m
         && M.cardinal l + M.cardinal r + 1 = List.length lst
       ) lst)
Index: ocaml-containers-2.5/src/threads/CCPool.ml
===================================================================
--- ocaml-containers-2.5.orig/src/threads/CCPool.ml
+++ ocaml-containers-2.5/src/threads/CCPool.ml
@@ -267,7 +267,7 @@ module Make(P : PARAM) = struct
     (*$R
       List.iter
         (fun n ->
-          let l = Sequence.(1 -- n) |> Sequence.to_list in
+          let l = Iter.(1 -- n) |> Iter.to_list in
           let l = List.rev_map (fun i ->
             Fut.make
               (fun () ->
@@ -283,7 +283,7 @@ module Make(P : PARAM) = struct
     (*$R
       List.iter
         (fun n ->
-          let l = Sequence.(1 -- n) |> Sequence.to_list in
+          let l = Iter.(1 -- n) |> Iter.to_list in
           let l = List.rev_map (fun i ->
             Fut2.make
               (fun () ->
Index: ocaml-containers-2.5/src/threads/CCThread.ml
===================================================================
--- ocaml-containers-2.5.orig/src/threads/CCThread.ml
+++ ocaml-containers-2.5/src/threads/CCThread.ml
@@ -32,7 +32,7 @@ end
   let l = CCLock.create 0 in
   let a = Arr.spawn 101 (fun i -> CCLock.update l ((+) i)) in
   Arr.join a;
-  let n = Sequence.(1 -- 100 |> fold (+) 0) in
+  let n = Iter.(1 -- 100 |> fold (+) 0) in
   assert_equal ~printer:CCInt.to_string n (CCLock.get l)
 *)
 
